\documentclass[a4paper]{jpconf}
\usepackage{url}
\usepackage{braket}
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage[fleqn]{amsmath}
\usepackage{slashed}
\usepackage{geometry}
\usepackage{marginnote}
\usepackage[mathscr]{euscript}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{wrapfig}
\usepackage{floatrow}
\usepackage{subfig}
\usepackage{pgfgantt}
\usepackage{rotating}
\usepackage[graphicx]{realboxes}
\bibliographystyle{iopart-num}
\begin{document}
\title{Quantum computing project}

\author{Sijia Gao}

\begin{abstract}
Applying quantum algorithm to match filtering problems in gravitational research
\end{abstract}

\section{Introduction}
\section{Grovers Algorithm}
Grover's algorithm provides a polynomial speed up for generic search problems. To find a good enough result in a database with N items, classically the complexity of this problem would be exponential. Even with the best known algorithms, which either prioritise certain candidates or utilise the structure of certain problems, the classical cost would still be exponential. 
\newline \newline In the classical situation, with k queries, the possibility of the correct output in a database with N items would be $\frac{k+1}{2^N}$.
\section{Quantum counting phase estimation }
\section{Python realisation of Grover's algorithm}
\section{Computational cost estimation}
With the initial assumption being all gates have the same computational cost, estimating the overal computational cost is the same as counting the number of gates. 
\newline\newline Suppose there are N templates. Classically, for each template we suppose it takes $k_1$ steps to compute the template from all the parameters, and $k_2$ steps to match the template to the data. In this way, to match all templates we need $N \cdot (k_1+k_2)$ steps before any search algorithm is applied. A typical classical search algorithm for N templates, in the worst scenario would cost $N-1$ steps. So the total cost would be $N \cdot (k_1+k_2+1)-1$.
\newline \newline Before we go into each steps, we shall first establish the differences between a classical computer and a quantum computer in this specific case.
\newline \newline In a quantum computer, we shall start with all the parameters as well. The difference being here the parameters are stored in a superposition in the form of 
\begin{equation}
\label{0}
    \frac{1}{\sqrt{N}}\sum^N_i\ket{\theta_i}.
\end{equation}
The orginal state would be comprised of four regitsers:
\begin{equation}
\label{step0}
    \frac{1}{\sqrt{N}}\sum^N_i\ket{i}_I\ket{0}_T\ket{Data}_D\ket{+}_A,
\end{equation}
the subscripts I, T, D and A represents the indices, the templates, data and the ancilla for Grover's algorithm respectively. 
\begin{itemize}
    \item Step 1: Compute N templates from the parameters. Cost: $k_1$
    \newline We assume for each template this should be the same cost as the classical computer. However, since all the calculation can be done in parallel, the cost would only be $k_1$. The state after this step would be: 
    \begin{equation}
\label{step1}
    \frac{1}{\sqrt{N}}\sum^N_i\ket{i}_I\ket{T_i}_T\ket{Data}_D\ket{+}_A,
\end{equation}
    \item Step 2: Matching the templates to the data in order to compute $f(x)$. Cost: $2k_2+2$
    \newline We assume for each template this should be the same cost as the classical computer. However, since all templates are stored in superposition, all the calculation can be done in parallel. The cost of calculating the overlap between the templates and the data would be $k_2$. However, in order to use the Grover's algorithm, we need to compare this result with a threshold to determine if we should add 1 or 0 to the ancilla. After we register the result on the ancilla, which would incur two more steps, we need to erase the inner product register. The erasing process is the reverse of the generating process. Accordingly, another $k_2$ cost is generated. Altogether, this step costs $2k_2+2$ steps. The state after this step would be: 
    \begin{equation}
\label{step2}
    \frac{1}{\sqrt{N}}\sum^N_i\ket{i}_I\ket{T_i}_T\ket{Data}_D\ket{+\oplus f(T_i)}_A,
\end{equation}
where $f(T_i)$ denotes if the overlap between the templates and the data is above the threshold.
    \item Step 3: Erasing the template. Cost: $k_1$.
    \newline In order to carry out the Gorver's algorithm we need only the indices and the ancilla register to be entangled. Therefore, the templates register needs to be erased. Accordingly, $k_1$ cost is generated. The state after this step would be: 
    \begin{equation}
\label{step3}
    \frac{1}{\sqrt{N}}\sum^N_i\ket{i}_I\ket{0}_T\ket{Data}_D\ket{+\oplus f(T_i)}_A,
\end{equation}
\end{itemize}
Then we can apply Grover's search algorithm, whose cost would be in the order of $\sqrt{N}$. Because all the previous steps are needed to be repeated for each iteration, the total cost for the quantum match filtering process should be: $2\sqrt{N}(k_1+k_2+1)$. Comparing with the classical cost of $N \cdot (k_1+k_2+1)-1$, this would be considerably smaller providing that $N$ is sufficiently big.
\section{Next step}
Although we have tried to realise this procedure in python, we are now trying to write out this circuit on the IBM quantum computing platform QISKit. Our first step is trying to realise a four-qubit Grover's search algorithm. We have got a very preliminary circuit as shown in Fig.\ref{q1} which might be able to be simplified in the future. 
\begin{figure}[h]
\includegraphics[width=\columnwidth]{qmatchfilting.JPG}
\caption{\label{q1} Preliminary circuit for the $U_f$ operator in the Grover's algorithm. }
\end{figure}
\section*{References}
\bibliography{bibbibi}
\end{document}


